# Book Recommendation Web App

A Flask-based book recommendation web application that combines content-based filtering (TF-IDF) and collaborative filtering (implicit ALS), with an MMR re-ranking step to balance relevance and diversity.

---

### Features 

- Content-based search using TF-IDF over book titles, supporting keyword queries and similar-book lookup from a seed title.
- Collaborative filtering recommendations using an implicit ALS model trained on user–book rating data. 
- Hybrid recommender that linearly combines content and collaborative scores and then applies MMR to encourage diverse suggestions. 
- Dislike list stored in session so users can hide unwanted books from future hybrid recommendations. 
- Simple web UI built with Jinja2 templates, including a main search form and a results page showing query metadata and recommendations. 

---

### Tech Stack 

- Backend framework: Flask.  
- Data and math: pandas, NumPy, SciPy.
- Machine learning: scikit-learn (TF-IDF), implicit (ALS matrix factorization). 
- Templates: Jinja2 HTML templates (`index.html`, `base.html`, `results.html`).  
- Model and artifact persistence: joblib, pickle, NumPy binary files, and CSV.

---

### Project Structure 

```
.
├── app.py           # Flask app and recommendation logic
├── train.ipynb         # Offline training and artifact export
├── templates
│   ├── base.html    # Base layout
│   ├── index.html   # Main UI and forms
│   └── results.html # Result summary page
└── artifacts        # Generated by train.ipynb
    ├── books.csv
    ├── tfidf_vectorizer.joblib
    ├── tfidf_matrix.npz
    ├── als_user_factors.npy
    ├── als_item_factors.npy
    └── id_mapping.pkl
```

The `artifacts` directory is created by `train.ipynb` and is loaded by `app.py` at startup.

---

### Data Requirements 

- `books.csv`: contains the book catalog with at least `book_id`, `title`, `image_url`, `authors`, `original_publication_year`, and `language_code`.  
- `ratings.csv`: contains user feedback with at least `user_id`, `book_id`, and a numeric `rating`.
- During training, ratings are filtered so that only `book_id`s present in `books.csv` are kept, ensuring consistency between the catalog and the interaction data.

---

### Installation 

1. Create and activate a Python 3 virtual environment.  
2. Install dependencies:

   ```
   pip install flask numpy pandas scipy scikit-learn implicit joblib
   ```

3. Place `books.csv` and `ratings.csv` in the project root directory.

---

### Training Pipeline (`train.ipynb`) 

The training script is responsible for preparing all artifacts required by the web app. 

Main steps: 

1. **Load and filter data**: read `books.csv` and `ratings.csv`, then keep only ratings whose `book_id` exists in the book catalog. 
2. **TF-IDF features**: fit a `TfidfVectorizer(stop_words="english")` on `books["title"].fillna("")` and build the sparse `tfidf_matrix`.  
3. **ALS model**: construct a user–item CSR matrix from ratings and train an implicit ALS model on that matrix to get `als.user_factors` and `als.item_factors`. 
4. **ID mappings**: build dictionaries mapping between raw IDs and matrix indices (`user_id_to_code`, `book_id_to_code`, `code_to_book_id`).
5. **Export artifacts** to the `artifacts/` folder: 

   - Cleaned `artifacts/books.csv` with aligned columns. 
   - `artifacts/tfidf_vectorizer.joblib` and `artifacts/tfidf_matrix.npz`.  
   - `artifacts/als_user_factors.npy` and `artifacts/als_item_factors.npy`. 
   - `artifacts/id_mapping.pkl` containing the ID mapping dictionaries.

---

### Web Application (`app.py`)

On startup, the Flask app loads the book catalog, TF-IDF artifacts, ALS factor matrices, and ID mappings from the `artifacts` directory. 

Key functions:

- `search_by_keyword(q, topn)`: TF-IDF keyword search over all titles, returning the top matches and their scores.  
- `content_neighbors(book_title, topn)`: finds the most similar books to a given title using cosine similarity in TF-IDF space. 
- `collaborative_recommend(user_id, topn)`: computes scores via the dot product between ALS user and item factors and returns the top books. 
- `hybrid_mmr(user_id, book_title, topn, alpha, lambda_div, disliked)`: fuses content and collaborative scores, filters out disliked books, and applies MMR-based re-ranking for diversity.

The app also includes a safeguard that checks the shapes of ALS factor matrices against mapping sizes and swaps them if training accidentally used a transposed matrix.

---

### Routes and UI

- `GET /`: renders `index.html`, providing:  
  - A dropdown of seed titles built from the books catalog.  
  - A list or range of available `user_id`s derived from `user_id_to_code`. 
  - Current dislike list retrieved from session, rendered as books with their titles.   

- `POST /ui_recommend`: handles the recommendation form submission. 
  - `filter_type` chooses between `content`, `collaborative`, and `hybrid` modes. 
  - `user_id` can be a specific ID or the special value `"auto"` to randomly pick one from known users.
  - `topn`, `alpha`, and `lambda_div` control the number of results and hybrid/MMR behaviour. 
  - Renders `results.html` with metadata such as method, user, seed title, and the list of recommended books.

- `POST /dislike`, `/remove_disliked`, `/clear_disliked`: manage the dislike list stored in the session so users can hide books they are not interested in.

---

### Running the App 

After generating artifacts with `train.ipynb`, start the web server with: 

```
python app.py
```

By default, the app runs in debug mode on `0.0.0.0:7001`, making the web UI accessible from a browser pointing to that host and port. 

---

### Configuration Notes 

- The secret key in `app.py` (`app.secret_key`) should be replaced with a strong random value before deploying. 
- ALS hyperparameters (factors, regularization, iterations) and TF-IDF options can be tuned directly in `train.ipynb`.  
- `topn`, `alpha`, and `lambda_div` are exposed via the UI so that users can experiment with list length, hybrid weighting, and the trade-off between relevance and diversity. 

